# Mysql的SSL连接

​	👀 用于加密客户端与服务器间通信，确保数据传输安全。配置涉及生成证书、修改配置文件以启用SSL，并重启服务应用设置。







###### 数字签名

> [!NOTE]
>
> 💰 私钥对数据进行D运算：**加密**
>
> 💰 公钥对数据进行E运算：**解密**

​	👀 通过加密，再通过解密，获得明文报文，可以确保报文完整性、不可否认、鉴别。

​	报文完整性：经过加密的报文被修改，无法顺利通过解密（程序上会报错）。

​	不可否认：私钥是独有的（在没有泄密的情况下），公钥匙公开的，报文经过加密，只能通过公钥进行E运算（不正确的公钥会报错）。

​	鉴别：私钥和公钥匙一对一的，报文经过加密，只能通过对应的私钥进行D运算。

> [!CAUTION]
>
> ​	💡 实际中，不可能对发送报文进行私钥D运算（十分消耗性能），引入散列函数，报文通过散列函数运算得到定长散列值，报文+加密散列值组成新报文，接收方比较解密后的散列值，和散列函数运算的拆分后报文。

---

###### 重放攻击

​	👀 发送方发送用户名和密码（经过加密），接收方解密后获取明文，比对数据库中的用户和密码，确认发送方身份，但是问题在于，发送发的报文被C截获，C可以使用这个报文欺骗接收方（C不需要去解密内容）。

> [!CAUTION]
>
> 💡 体现在截获的报文可以多次使用，C可以通过截获报文随时欺骗接收方。

---

###### 不重数

​	👀 在鉴别身份的报文中加入随机数（发送方记录接收方发送的随机数，反之亦然）

​	 发送方发送用户名、密码、随机数A，接收方收到。

​	 接收方发送加密随机数A、随机数B，发送方接收，解密随机数A，确认身份（发送方明确自己的随机数是发送给谁的）。

​	 发送方发送加密随机数B，接收方接收，解密随机数B，确认身份（同理）

> [!CAUTION]
>
> 💡C无法通过截获报文开启新的会话（比如截获随机数B的报文，欺骗接收方），欺骗接收方，截获的报文只能使用一次，接收方有随机数的记录，并且已经开启过会话（前提是肯定对整个报文有数据签名的，C不能对报文做修改，比如修改随机数后，发送报文）。

> [!CAUTION]
>
> 💡 C还是可以截获接收方发送随机数B，C加密随机数B后发送，达到欺骗的效果。（只能使用一次）。

---

###### 中间人攻击

> [!NOTE]
>
> 💰发送方：**A** 
>
> 💰接收方：**B** 
>
> 💰截获方：**C** 
>
> 💰A用户名密码：**身份**
>
> 💰发送方随机数：**Rb**

​	👀 A发送身份，C截获继续转发，B接收到。

​	     B发送Rb，C截获继续转发（A接收到Rb，使用SKa加密Rb，发送给B，中途被C截获，直接丢弃。）,同时使用SKc加密Rb，发送给B。

​	   B收到SKc加密Rb，向A获取PKa,C截获继续转发（A收到发送自己的PKa，中途被C截获，直接丢弃），同时发送PKc给B。

​	经过密钥互换和身份鉴别后，B发送PKc加密的报文，C截获通过SKc解密后，在使用PKa加密继续转发给A，

A收到使用SKa解密。A和B完全不知道C的存在，但是报文内容被C完全了解。

> [!CAUTION]
>
> 💡 前提：对称加密和非对称加密，在没有密钥分配机构的情况，始终是需要传输密钥和公钥的。

---

###### 密钥分配协议

> [!NOTE]
>
> 💰鉴别服务器：**AS** 
>
> ​	👀  AS保存A登记身份、口令、Ka密钥，用于分配登记用户之间通信的一次性密钥。
>
> 💰票据授予服务器：**TGS**
>
> 💰请求的客户：**A**

---

##### SSL协议

👀  在安全的情况下，客户端和服务端交换对称密钥，后续的HTTP报文会通过这个密钥加密，也可以用于其他的应用层协议。

###### SSL协议过程

1. A向B发送SSL版本号和可供使用的加密算法，B返回支持的加密算法。
1. B向A发送在CA机构申请的数字证书，A使用对应机构公钥对证书进行验证。

> [!CAUTION]
>
> CA机构版本颁发给B的证书，会使用CA私钥进行数字签名，而对应的公钥包含在初始系统对应根证书中。

> [!CAUTION]
>
> CA机构颁发给B数字证书，包含属于B的公钥，B的私钥由自己保存。

3. 验证通过，A产生一组长随机数（实际就是A、B通信的加密密钥），再通过数字证书的公钥加密，发送给B

B收到通过对应私钥解密。

4. 后续双方的通信可以通过对称密钥加密。





