# 面试宝典

###### B树和B+树的区别

​	B树数据保存在所有节点中，包括叶节点和树干节点，一般用作文件系统的存储结构。

​	B+树是mysql的索引使用的结构，叶节点存储所有的数据，并且叶节点之前是通过链表连接的

###### Http和Https的区别

​	在于Https协议新增了SSL协议，SSL协议主要是产生会话密钥，用于加密Http协议的内容。

###### 数字证书

​	包含证书所有者的**公钥**、所有者**身份信息**和**数字签名**。

​	数字签名是CA机构使用CA的私钥对证书里面的公钥和身份信息进行了签名。

###### 索引创建过多影响

1.索引会占用存储空间

2.索引过于复杂会导致执行计划的优化有影响

3.数据表的删除和新增索引需要同步构建，影响效率。

###### 进程和线程的区别

​	进程可以说一个运行的程序，进程和进程之间的数据是相互隔离的。

​	线程是CPU分片调度的最小单位，通过CPU分配运行时间,线程和线程之前的资源可以互相访问，而且进程可以创建多个线程。

###### Redis缓存雪崩如何处理

​	分散Key的过期时间，不在某个集中点过期。

​	在项目启动期间，预热缓存数据。

###### Arraylist和linkedlist区别

Arraylist是基于数组结构,适合随机访问，插入操作需要移动后续元素，还会自动扩容

linkedlist基于双向链表的结构,适合插入操作和删除,随机访问需要遍历元素,适合队列和栈等数据结构

###### JVM相关知识

###### 线程的生命周期

​	创建线程进入**新建状态**--->调用start进入**就绪状态**，等待CPU时间片--->执行run方法,进入**运行状态**--->执行完毕进入**死亡状态**

​	运行过程调用sleep wait join进入**等待状态**,等待结束后或通过notify唤醒的线程进入**就绪状态**等待CPU时间片。

​	运行的线程进入同步代码，会进入**阻塞状态**，另一个线程释放同步锁后，从阻塞状态进入就绪状态，等待CPU分片

###### 如何停止一个执行的线程

​	执行线程的stop方法

​	共享变量方式，线程中使用while(共享变量条件成立循环)，在另外线程中修改共享变量，达到停止线程的目的

​	使用interupt方法修改标志位，中断wait和sleep方法，抛出异常，停止线程。

###### 类加载器的双亲委派

​	Java默认有三种类加载器，系统加载器、扩展加载器、应用加载器，对应加载不同路径下的class文件。当类加载器加载class文件时，判断对应类加载器是否有父加载器，如果存在再由父加载器判断是否已经加载过，直到系统类加载器，再由父加载器,如果不存在，在交给扩展类加载器，直到应用加载器。

###### 全盘委托加载

​	类加载器加载class类，其依赖也会交由当前类加载器加载，并且整个过程遵循双亲委派机制。

[1]: https://www.cnblogs.com/tomakemyself/p/13907994.html

###### 如果存在同包名同类名的类会发生什么

​	类加载会根据加载顺序优先加载靠前的

###### Java的==和equal比较的区别

​	==是值引用的比较、equal本质也是引用的比较，java对象Integer和String做了重写。

###### HashMap和HashTable、CurrentHashMap区别

​	HashTable和CurrentHashMap 是线程安全的,CurrentHashMap性能高于HashTable,使用CAS和SYnc关键字优化。

​	HashMap不是线程安全的	

###### 循环依赖注入的解决方案	

​	A B 互相依赖

​		通过@Lazy注解完成懒加载解决依赖注入

​		通过在实现注入对象的Set方法，通过set注入的方式解决

​	A依赖B B依赖C C依赖A

​		例如A依赖B的使用方法，单独抽离出来放入一个对象，A依赖新的对象即可。

###### Mysql的SQL优化方向

​	首先简化查询列，避免使用select *，left Join小表在左侧,避免对列进行函数运算，in查询范围值的时候，使用exsist代替。

​	创建合适的索引利用索引覆盖的特性，多列查询可以复合索引。

​	通过mysql 的explain执行计划，主要观察type和Extra的值。

​	重建表，冗余关联字段，减少查询逻辑。

###### Java静态代理和动态代理的区别

​	**静态代理**由接口、实现类、代理类组成，由开发人员手动编写代码实现，具体实现为代理类和实现类分别实现接口，在代理类中定义代理类对象并且实现初始化赋值，然后在代理类实现方法中调用实现类方法，并且可以在代理类实现方法中编写增强代码。

​	**动态代理**由接口、实现类、代理类组成，但是在运行时创建的，通过java反射类型提供的方法，同时传递一个实现了invocationHanlder的对象返回代理类。

###### Mysql的MVCC机制

###### Redis的分布锁机制

###### 跨域资源共享（CORS）

###### 如何判断是否存在内存泄漏的情况

###### 如何判断是否存在死锁的情况

###### 如何定位CPU**飙升**的问题

###### Java中Final关键子的作用

​	1.类使用，不能被继承

	2. 方法使用，方法不能被重写
		1. 变量使用,必须初始化并且不能被修改。

###### HashMap的实现原理

​	HashMap是基于数组和链表的方法构成，HashMapput元素的时候，根据key计算hash值再根据hash值确定索引下标，如果出现Hash重复，将以链表的方式存放，新增的数据放入表头。

​	发生Hash冲突，在通过Key获取元素的时候，不仅会计算Hash定位索引坐标，还会调用equals比较key的值，找到对应的value元素。

###### Set集合使用

​	首先set是一个不允许出现重复元素的集合,大多数情况是无序的。

​	Hashset: 基于HashMap实现，

​	Linkhashset:在Hashset的基础上通过双向链表维护set的有序性。

​	treeset:基于红黑树实现有序set集合。

###### 线程创建的3种方式

​	1.通过继承Thread。

​	2.通过实现Runnable。

​	3.Callable和FutureTask。

###### Callable和Runnable的区别

​	Callbale 是有返回值的，可以配置futrue Task配合异步获取返回值结果。

​	Runnable 没有返回值。

###### **简述 tcp 和 udp的区别**

​	TCP是面向连接的,建立连接一下需要协商参数，UDP是无连接的，发送数据之前不需要建立连接。

​	TCP提供的是可靠服务,报文是按序，无差错到达，UDP是尽最大交付，不保证数据完整性。

​	UDP的工作效率比TCP的效率要高。

​	TCP连接是点对点的连接，UDP支持一对一、和一对多。

​	TCP系统资源占用比UDP占用资源要多。

###### 什么是3次握手4次挥手

###### SpringBean是线程安全的吗	

​	SpringBean模式的单例的模式，其中的变量可以被多个线程访问，他们不是线程安全的

###### Springboot事务失效的原因

1. 方法内直接调用当前对象方法。
2. 方法的访问权限必须设置为public。
3. 调用方法的对象必须要被spring托管。
4. springmvc项目中未开启全局事务的配置。
5.  方法不能被final修饰,spring通过AOP实现事务管理，使用了JDK动态代理对方法进行增强。

###### Springboot事务回滚失败的原因

1.  Springboot 事务管理默认对RuntimeException和Error异常抛出，触发事物回滚，事务内抛出的异常不匹配。

2.  Springboot事务管理指定异常抛出后回滚事务，事务内抛出的异常不匹配。

3.  代码出现异常后，手动捕获异常,Spring事务也不会回滚。
4.  设置错误的事务传播级别，比如设置为nerver，表示不支持事务。
5.  在多线程环境中，每个线程的事务时独立的，某个线程异常不会导致另一个线程触发回滚。

[1]: https://blog.csdn.net/HJW_233/article/details/131993937?spm=1001.2014.3001.5501

###### Hystrix的基本概念

​	熔断：规定时间内错误率达到百分比阈值，指定时间内服务不可用。

​	限流：规定时间内允许的QPS值，超出QPS的部分不可用。

###### 乐观锁和悲观锁的概念

​	**悲观锁：**悲观锁假设并发操作一定会发生线程竞争的情况,因此在操作过程中全程加锁，保证只有一个线程可以访问。

​	**乐观锁：**乐观锁假设并发操作不总会发生冲突，属于小概率事件，因此不会采用加锁的方案，采用比较交换的策略,首先读取变量的版本，然后执行操作，最后比较读取变量的版本和当前版本是否一致，如果一致则表示在运行期间没有对变量进行修改，即可设置新值，如果不一致，则重复读取、操作、比较的过程。

###### valolite关键字

​	主要是使用在变量上，可以保证变量的**有序性**和**可见性**。

​	可见性：

​	有序性：

###### 如何保证RabbitMq消息不丢失	

​	1.确保开启了队列和消息的持久化。

​	2.发送端开启发布订阅机制，确保消息发送成功

​	3.消费端关闭自动应答的机制，采用手动确认的方法，如果消费不成功，重入队列。

​	4.配置死信交换机，面对消息格式异常的数据，采用手动应答后，无需重入队列，

直接进入死信交换机,由开发人员排查原因,同时接收队列超长和排队超时消息。

###### 什么是线程安全

###### 线程池的工作流程

###### 线程池有哪些状态

​	运行状态

​	关闭状态

​	停止状态

​	TIDYING

​	TERMINATED

###### Mysql如何排查死锁问题

​	通过SHOW ENGINE INNODB STATUS,查看status列，并且检索关键字**TRANSACTIONS**查看当前活跃事务，正在等待锁的执行SQL。

​	通过my.cnf 中的指定log_error的位置，检索deadlock的关键字查找死锁执行SQL。

###### Mysql死锁常见的原因

​	两个事务修改相同的表的数据行，事务A修改A表前B表后，事务B修改B表前A表后，执行顺序不一致，会导致死锁。

​	使用for update的时候，没有对表添加where，导致锁表。

​	避免大事务的使用，减少锁占用的时间。

###### Mysql减少死锁的办法

​	业务允许，可以降低事务的隔离级别，从可重复读降低到读已提交。

​	定期通过show engine innodb status;查看存在锁死的SQL，调整SQL的执行。

​	在使用到for update的时候，需要执行where条件,同时创建合适的索引，避免在全表扫描期间对数据上锁。

​	使用版本号机制更新数据,避免锁的冲突。

###### &和&&的区别

​	同样都是与运算，&&在第一项为false时候就停止运算第二项，&则两项都会运行。

###### IOC和AOP

​	IOC控制反转：旨在把对象初始化的过程，交由给spring处理，程序员只需要对应的注入方式即可拿到对应的实现对象。

​	AOP面向切面编程：旨在Sping通过IOC管理的对象的方法，开发人员可以通过不修改原有逻辑的情况下,增强方法。

###### 谈谈对JVM的理解

​	JVM是由

​	**类加载器**: 将.class文件加载到JVM中,使其可以被java程序使用。

​	**运行时数据区**: 指的是JVM的内存模型,用于存储在运行期间的数据。

​	**执行引擎**: 执行引擎负责执行 JVM 中的字节码指令。

​	**本地方法接口**: Java通过本地方法接口调用native方法

​	**本地方法库**:类加载classpath下的库文件。

###### 为什么Java可以一次编译到处运行

​	首先java程序的执行过程是由java程序到JVM虚拟机到操作系统。

​	1.java文件是直接运行在JVM上的，与操作系统无关。

​	2.java程序不直接调用操作系统指令，而是通过JVM调用,屏蔽底层细节。

​	3.不同操作系统，有不同的JVM的实现。



​	
